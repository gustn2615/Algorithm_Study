/* 문제
 * 초콜릿이 있는데, 이 초콜릿은 막대 모양이다. 각 막대는 정사각형 N개로 이루어져 있다.
 * 초콜릿의 크기는 항상 2의 제곱 형태이다.
 * 상근이는 초콜릿이 정확하게 K개가 되도록 쪼개려고 하는데,
 * 초콜릿의 크기가 D인 경우, 항상 D/2개의 막대 두 조각으로만 쪼개질 때
 * 최소 몇 번 쪼개야 하는지와 사야하는 가장 작은 초콜릿의 크기를 구해보자.
 * 
 * 
 * 조건
 * K개는 1 이상 백만 이하의 자연수이다.
 * 
 * 
 * 아이디어
 * K개의 조각이 필요하다면, 최소 K개 이상의 초콜릿 크기가 필요하다.
 * K보다 큰 길이가 D인 초콜릿을 골랐다면, 절반으로 나눈다.
 * 절반으로 나누면, D/2가 되는데, D는 항상 2의 제곱이므로
 * K는 D/2 < K <=D 의 범위를 갖게 된다.
 * 이를 이용해서, K-D/2를 한다.
 * 그렇다면 K는 0< K <= D/2의 범위를 갖게 된다.
 * 다시 D/2를 2로 나눈 후, K의 크기와 비교해보자.
 * K와 같다면 종료하고, D/4가 K보다 작다면 K는 D/4 < K <D/2 인 것이므로,
 * 다시 K - D/4를 하고 위 과정을 반복한다.
 * D/4가 K보다 크다면 0 < K <= D/4의 범위를 갖게되는 것 이므로
 * K에는 어떤 짓도 하지 않고 다시 D/4를 2로 나누어 위 과정을 반복해보자.
 * 
 * 
 */

package Baekjun;

import java.util.Scanner;

public class P2885 {
	public static void main(String[] args) {

		Scanner sc = new Scanner(System.in);

		// K를 입력 받는다.
		int K = sc.nextInt();

		// K보다 큰 2의 제곱수를 찾아보자.
		int D = 1;
		while (D < K) {
			D *= 2;
		}

		// 쪼개는 수를 저장할 변수를 만든다.
		int cnt = 0;
		// 초콜릿의 크기를 저장해 놓는다.
		int chocolateSize = D;

		// 이제 K는 0<K<=D/2의 범위를 갖는다.
		// K와 D가 같아질 때 까지 반복해보자.
		while (K != D) {
			// K가 D/2보다 큰 경우
			if (K > D / 2) {
				// K에서 D/2를 빼자.
				K -= D / 2;
			}
			// K가 D/2보다 작은 경우는 K는 그대로 있어도 되겠다.
			D /= 2;
			// 쪼개는 수를 하나 늘려주자.
			cnt++;
		}

		// 출력
		System.out.println(chocolateSize + " " + cnt);

	}
}
